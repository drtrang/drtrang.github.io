[{"title":"Guava 学习手册","date":"2017-07-13T08:42:08.155Z","path":"2017/07/13/Guava 学习手册/","text":"Guava是Google的一个开源项目，包含许多Google核心的Java常用库。 1. com.google.common.base1.1 字符串处理Guava把字符串处理动作分了几大类，每种动作都有对应的工具类实现，我们可以根据需要使用对应的工具类。 1.1.1 CharMatchercom.google.common.base.CharMatcher是Guava提供的用于进行字符匹配的工具类，翻开CharMatcher的源码，我们知道CharMatcher是一个抽象类，在其内部Guava做了大量默认实现，用来更方便的对字符串做匹配，并通过构造者模式对匹配后的字符串进行处理。 注：不支持正则表达式 1.1.2 Joinercom.google.common.base.Joiner用来拼接字符串，可以避免大量的手动拼接appendTo()方法，Joiner可以实现Iterable&lt;?&gt;、Object[]、Map&lt;?, ?&gt;类型的拼接。但要实现基本类型数组的拼接就无能为力了，这时就需要借助com.google.common.base.primitives包的基本类型工具类来实现了。 Joiner底层通过StringBuilder实现，非线程安全。 1.1.3 Splittercom.google.common.base.Splitter用来分割字符串，可以方便的以任意字符分割字符串，并提供转换为Map的方法MapSplitter withKeyValueSeparator(String separator)。 注：支持正则表达式分割字符串。 1.1.4 Stringscom.google.common.base.Strings的功能较少，Guava提供的其它几个工具类已基本可以实现字符串处理的相关功能。 1.1.5 Charsets字符串编码一直是我们很头疼的事情，相信我们都写过这样一行代码：12String s = &quot;trang&quot;;byte[] bytes = s.getBytes(Charset.forName(&quot;UTF8&quot;)); 这样写有很多缺点，首先我们的大脑得记住常用的字符串编码，不是UTF_8，不是UTF+8，只能是UTF-8或者UTF8，其次错误输入后的后果也很严重，JVM会抛出java.nio.charset.UnsupportedCharsetException异常。 com.google.common.base.Charsets给我们提供了一种便利的方式，Charsets类提供了常见的Charset编码集，给我们的大脑腾出了位置并且避免了异常。 注：Java7中提供了类似功能的java.nio.charset.StandardCharsets类 1.1.6 CaseFormatcom.google.common.base.CaseFormat很机智的替我们解决的大小写转换的问题，并且提供了额外的内容。 在处理数据库与POJO的映射时，该类有奇效。 类型 说明 示例 LOWER_CAMEL 小写驼峰 lowerCamel LOWER_HYPHEN 小写连接符 lower-hyphen LOWER_UNDERSCORE 小写下划线 lower_underscore UPPER_CAMEL 大写驼峰 UpperCamel UPPER_UNDERSCORE 大写下划线 UPPER_UNDERSCORE 1.2 函数式编程在Java8面世之前，Guava一直是函数式编程的不二之选，但过度使用Guava函数式编程会导致冗长、混乱、可读性差而且低效的代码。这是迄今为止最容易（也是最经常）被滥用的部分，如果你想通过函数式风格达成一行代码，致使这行代码长到荒唐，Guava团队会泪流满面。 Predicate和Function是函数式编程中最重要的两个接口，通常通过匿名内部类的方式实现自己的函数，也可以通过对应的工具类使用Guava已为你写好的函数。 1.2.1 Predicatecom.google.common.base.Predicate&lt;T&gt;，断言预期结果，如果与预期不符则放弃。Predicate只声明了一个方法boolean apply(T input)，使用时只需要实现断言表达式即可。 CharMatcher和Range也是通过Predicate实现的。 常见使用Predicate的方法： Iterables.filter(Iterable&lt;T&gt; unfiltered, Predicate&lt;? super T&gt; predicate) FluentIterable.filter(Predicate&lt;? super T&gt; predicate) Collections2.filter(Collection&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) Sets.filter(Set&lt;T&gt;, Predicate&lt;? super T&gt;) Maps.filterKeys(Map&lt;K, V&gt; unfiltered, Predicate&lt;? super K&gt; keyPredicate) Maps.filterValues(Map&lt;K, V&gt; unfiltered, Predicate&lt;? super V&gt; valuePredicate) Maps.filterEntries(Map&lt;K, V&gt; unfiltered, Predicate&lt;? super Entry&lt;K, V&gt;&gt; entryPredicate) Multimaps.filter(Predicate&lt;? super E&gt; predicate) 1.2.2 Functioncom.google.common.base.Function&lt;F, T&gt;，函数，Function最常用的功能是转换集合，同样只需要实现T apply(F input)即可愉快的玩耍了。 常见使用Function的方法： 与`Predicate`基本一致 1.2.3 Suppliercom.google.common.base.Supplier&lt;T&gt;可以对传入的对象进行包装构建后再输出。与前两个函数接口一样，Supplier只提供了一个供实现的方法T get()，用于获取包装后的对象。由于Supplier在对象的外层，所以Supplier的一个重要作用是赋予对象懒加载的特性。 1.3 其它工具类1.3.1 OptionalGuava用com.google.common.base.Optional表示可能为null的T类型引用。一个Optional实例可能包含非null的引用（我们称之为引用存在），也可能什么也不包括（称之为引用缺失）。它从不说包含的是null值，而是用存在或缺失来表示。但Optional从不会包含null值引用。 Optional最大的优点在于它是一种傻瓜式的防护。Optional迫使你积极思考引用缺失的情况，因为你必须显式地从Optional获取引用。 1.3.2 Stopwatchcom.google.common.base.Stopwatch是一种灵活的代替System.currentTimeMillis()和System.nanoTime()的方式。 你可以把Stopwatch想象成一个秒表，它支持暂停和重置，并且支持java.util.concurrent.TimeUnit的任何计时单位。 2. com.google.common.collect2.1 拓展集合Guava对Java默认的集合做了大量拓展，以实现不同的业务需求。 2.1.1 ImmutabelMapGuava的Immutable系列被很多人推崇，Immutable对象的数据在创建时提供，并且在整个生命周期内不可变，这样带来了一些好处： 1. 线程安全 2. 节省空间，有效利用内存 3. 可当做常量使用 以前我们常使用Collections.unmodifiableXxx()来定义常量集合，但我们都知道它是有缺陷的。以后当我们使用常量集合时，推荐大家使用Guava的Immutable集合，Guava把所有集合类都建立了对应的不可变集合。 常见ImmutabelMap实现类：| 可变集合类型 | 来源 | Guava不可变集合| :– | :– | :– || Collection | JDK | ImmutableCollection| List | JDK | ImmutableList| Set | JDK | ImmutableSet| SortedSet | JDK | ImmutableSortedSet| Map | JDK | ImmutableMap| SortedMap | JDK | ImmutableSortedMap| Multiset | Guava | ImmutableMultiset| SortedMultiset | Guava | ImmutableSortedMultiset| Multimap | Guava | ImmutableMultimap| ListMultimap | Guava | ImmutableListMultimap| SetMultimap | Guava | ImmutableSetMultimap| BiMap | Guava | ImmutableBiMap| ClassToInstanceMap | Guava | ImmutableClassToInstanceMap| TypeToInstanceMap | Guava | ImmutableTypeToInstanceMap| Table | Guava | ImmutableTable| RangeSet | Guava | ImmutableRangeSet| RangeMap | Guava | ImmutableRangeMap 注：1. 当进行add、remove等操作时抛出java.lang.UnsupportedOperationException，该异常为运行时异常，并不会在编译时提醒你，需要开发时注意2. 所有ImmutableMap均不支持null值3. 所有ImmutableMap均不支持插入相同的key 2.1.2 MultiSetcom.google.common.collect.Multiset&lt;E&gt;和Set的区别是可以保存多个相同的对象。在JDK中，List和Set有一个基本的区别，就是List有序且可重复，而Set不能有重复，也不保证顺序（有些实现有顺序，例如LinkedHashSet和SortedSet等）所以Multiset占据了List和Set之间的一个灰色地带：允许重复，但不保证顺序。 常见使用场景：Multiset有一个有用的功能，就是跟踪每种对象的数量，所以你可以用来进行数字统计。1HashMultiset.&lt;Integer&gt;create().count(element); 常见MultiSet实现类：| Value类型 | 来源 | Gauva Multimap| :– | :– | :– || Enum | JDK | EnumMultiset| HashMap | JDK | HashSetMultiset| LinkedHashMap | JDK | LinkedHashMultiset| TreeMap | JDK | TreeMultiset| ConcurrentHashMap | JDK | ConcurrentHashMultiset| ImmutableMap | Guava | ImmutableMultiset 2.1.3 MultiMapGuava中提供了形如Map&lt;K, List&lt;V&gt;&gt;或者Map&lt;K, Set&lt;V&gt;&gt;的新集合com.google.common.collect.Multimap&lt;K, V&gt;，方便的实现了把一个键对应到多个值的数据结构。 常见MultiMap实现类：| Value类型 | 来源 | Gauva Multimap| :– | :– | :– || ArrayList | JDK | ArrayListMultimap| LinkedList | JDK | LinkedListMultimap| HashSet | JDK | HashMultimap| LinkedHashSet | JDK | LinkedHashMultimap| TreeSet | JDK | TreeMultimap| ImmutableList | Guava | ImmutableListMultimap| ImmutableSet | Guava | ImmutableSetMultimap 注：1. MultiMap并不是Map2. 除了两个ImmutableMap，其它均支持null键和null值 2.1.4 BiMapcom.google.common.collect.BiMap&lt;K, V&gt;是一个双向Map，在BiMap中，键值都是唯一的。 常见BiMap实现类：| Value类型 | 来源 | Gauva Multimap| :– | :– | :– || HashMap | JDK | HashBiMap| EnumMap | JDK | EnumBiMap| EnumMap | JDK | EnumHashBiMap| ImmutableMap | Guava | ImmutableBiMap 2.1.5 Tablecom.google.common.collect.Table&lt;R, C, V&gt;代替了形如Map&lt;FirstName, Map&lt;LastName, Person&gt;&gt;的集合，通过行和列来确定唯一的值。 常见Table实现类：| Value类型 | 来源 | Gauva Multimap| :– | :– | :– || HashMap | JDK | HashBasedTable| TreeMap | JDK | TreeBasedTable| ImmutableMap | Guava | ImmutableTable| | Guava | ArrayTable 2.1.6 ClassToInstanceMapcom.google.common.collect.ClassToInstanceMap&lt;B&gt;是一种特殊的Map：它的键是类型，而值是符合键所指类型的对象。 Guava提供了两种有用的ClassToInstanceMap实现：com.google.common.collect.MutableClassToInstanceMap和 com.google.common.collect.ImmutableClassToInstanceMap。 为了扩展Map接口，ClassToInstanceMap额外声明了两个方法：T getInstance(Class&lt;T&gt;) 和T putInstance(Class&lt;T&gt;, T)，从而避免强制类型转换，同时保证了类型安全。 123ClassToInstanceMap&lt;Object&gt; map = MutableClassToInstanceMap.create();map.putInstance(Integer.class, 0);map.putInstance(String.class, &quot;1&quot;); 注：通常泛型为java.lang.Object 2.1.7 Range@TODOcom.google.common.collect.Range&lt;C extends Comparable&gt;com.google.common.collect.RangeSet&lt;C extends Comparable&gt;com.google.common.collect.RangeMap&lt;K extends Comparable, V&gt; 2.2 集合工具类Guava对JDK内置和Guava拓展的集合均开发了工具类，分别为Collections2、Iterables、Lists、Sets、Maps、Queues、Multisets、Multimaps、Tables，里面囊括了异常强大的静态工具方法。 Guava对拓展的具体集合实现类没有提供基于工具类的初始化方法，而是直接在集合类中提供了静态工厂方法。 2.2.1 Collections2com.google.common.collect.Collections2提供的方法不多，最常用的方法是函数编程的两个方法，具体内容在 1.2 函数式编程： Collection&lt;E&gt; filter(Collection&lt;E&gt; unfiltered, Predicate&lt;? super E&gt; predicate) Collection&lt;T&gt; transform(Collection&lt;F&gt; fromCollection, Function&lt;? super F, T&gt; function) 2.2.2 Iterablescom.google.common.collect.Iterables为所有实现java.lang.Iterable&lt;T&gt;接口的类提供了大量实用方法。如果你使用了Iterator，Guava同样为你提供了Iterators，它们的作用基本一致。 Iterables并不会傻瓜式的任何方法都会遍历对象，而是很精明的通过instanceof判断对象实际的类型，如果匹配上则调用该类型的方法，匹配不上才会遍历。 注：建议用Iterables代替Collections2 2.2.3 Listscom.google.common.collect.Lists提供了创建List的工厂方法，其余有用的有两个： List&lt;List&lt;B&gt;&gt; cartesianProduct(List&lt;? extends List&lt;? extends B&gt;&gt; lists) List&lt;T&gt; reverse(List&lt;T&gt; list) Lists没有函数编程的filter()方法，需要使用工厂方法代替实现：1Lists.newArrayList(Iterables.filter(from, Predicates.contains(Pattern.compile(&quot;[2-9]&quot;)))); 2.2.4 Sets由于Set的不重复特性，我们常用Set实现一些算法，而com.google.common.collect.Sets贴合实际的满足了我们的要求，提供了交集、并集、差集等多种运算方式，并定义了视图com.google.common.collect.Sets.SetView来展示结果。 SetView&lt;E&gt; intersection(final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) SetView&lt;E&gt; union(final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2) SetView&lt;E&gt; difference(final Set&lt;E&gt; set1, final Set&lt;?&gt; set2) SetView&lt;E&gt; symmetricDifference(final Set&lt;? extends E&gt; set1, final Set&lt;? extends E&gt; set2) MultiSet的工具类为com.google.common.collect.MultiSet。 2.2.5 Mapscom.google.common.collect.Maps提供了Map、SortedMap、BiMap的工厂方法及工具，Multimap的工具类为com.google.common.collect.Multimaps。 Maps中比较常用的方法是ImmutableMap&lt;K, V&gt; uniqueIndex(Iterable&lt;V&gt; values, Function&lt;? super V, K&gt; keyFunction)。 2.3 比较器2.3.1 ComparisonChain在Java中，我们实现排序往往有两种方式： 1. 要排序的对象实现`java.lang.Comparable&lt;T&gt;`接口，重写`compareTo(T o)`方法 2. 定义排序对象，实现`java.util.Comparator&lt;T&gt;`接口，重写`compare(T o1, T o2)`方法 重写比较方法是件麻烦的事情，Guava又一次帮我们逃离苦海，利用com.google.common.collect.ComparisonChain轻松愉快的完成比较方法。12345678public int compare(Cut cut1, Cut cut2) &#123; // 按照Rorate -&gt; X -&gt; Y 排序 return ComparisonChain.start() .compare(cut1.getRotate(), cut2.getRotate()) .compare(cut1.getX(), cut2.getX()) .compare(cut1.getY(), cut2.getY()) .result();&#125; 2.3.2 OrderingComparisonChain带来的功能仍然比较单一，而Guava同时为我们提供了异常强大且方便的链式调用比较器com.google.common.collect.Ordering&lt;T&gt;，Ordering实现了Comparator接口，所以完全可以用Ordering替代Comparator。 Ordering提供了大量的默认实现，每个比较器都提供了常见的链式调用方法，大家可以根据实际情况创建自己的比较器。 注：1. 基本类型的比较可以使用com.google.common.base.primitives包2. Java8中提供了类似功能的java.util.Comparators类 3. com.google.common.cache缓存是一个成熟的系统中必不可少的一环，合理利用缓存可以显著提升系统响应速度，减少I/O压力，Java常见的缓存有Redis、Memcached、EhCache等，而今天我们介绍的是Guava提供的本地缓存Guava Cache。 Guava Cache在很多场景下都是相当有用的，比如初始化查找树，我们只需要对不同的树初始化一次，以后直接调用即可。 Guava Cache与ConcurrentMap很相似，但不完全一样。最基本的区别是ConcurrentMap会一直保存所有添加的元素，直到显式地移除。相对地，Guava Cache为了限制内存占用，通常都设定为自动回收元素。 3.1 应用缓存3.1.1 Cachecom.google.common.cache.Cache&lt;K, V&gt;是Guava Cache的基本接口，Guava为我们提供了一个默认实现LocalManualCache，我们可以通过CacheBuilder工具类的工厂方法来创建LocalManualCache对象。 1CacheBuilder.newBuilder().build() 3.1.2 CacheLoader在使用Guava Cache前，首先问自己一个问题：有没有合理的默认方法来加载与键关联的值？如果没有，Cache就是为你打造的，你需要在获取缓存的值时传入一个Callable实例来保证Guava Cache的作用。如果有，那么CacheLoader更适合你，而这也是今天的重点。 com.google.common.cache.LoadingCache&lt;K, V&gt;是实现了CacheLoader的Guava Cache，与创建Cache实例时仅有一点不同，只需要调用build()的重载方法即可。 1CacheBuilder.newBuilder().build(cacheLoader); 正因为LoadingCache有了默认的加载方法，所以只需要调用get(K key)即可得到值。 3.2 自定义缓存3.2.1 CacheBuilder从之前的代码中大家都看到了，Guava Cache的实例正是通过CacheBuilder创建的，事实上，CacheBuilder的作用远远不止这些，掌握好CacheBuilder，享受自定义Guava Cache的乐趣吧。 自定义CacheBuilder参数：| 方法 | 参数 | 说明| :– | :– | :– || initialCapacity | int | 初始化容量| maximumSize | long | 最大容量| weigher | Weigher | 权重函数| maximumWeight | long | 最大权重| concurrencyLevel | int | 并发级别| expireAfterAccess | long, TimeUnit | 上次访问给定时间后回收| expireAfterWrite | long, TimeUnit | 缓存写入给定时间后回收| refreshAfterWrite | long, TimeUnit | 缓存写入给定时间后更新| removalListener | RemovalListener | 移除监听器(同步)| recordStats | | 统计状态 CacheBuilder提供了一系列的参数供我们个性化，主要是为了缓存的回收。CacheBuilder创建的实例并不会自动清理失效的缓存，而是在你进行读或写操作的时候顺带维护。这样做的原因在于，如果要自动地持续清理缓存，就必须有一个线程，这个线程会和用户操作竞争共享锁。 4. com.google.common.net常用类@Beta: HostAndPort HostSpecifier InetAddresses InternetDomainName MediaType PercentEscaper UrlEscapers @Release: HttpHeadersGuava中的com.google.common.net包目前提供的功能较少，而且大多类都标注了@Beta的注解，在Guava中标记@Beta表示这个类还不稳定，有可能在以后的版本中变化，或者去掉，所以不建议大量使用，这里也是只做简单的介绍。 4.1 HttpHeaders先介绍下唯一一个没有@Beta注解的类HttpHeaders，这个类中并没有实质的方法，只是定义了一些Http头名称的常量，通常如果需要我们会自己定义这些常量，如果你引用了Guava包，那么就不再建议我们自己定义这些头名称的常量了，直接用它定义的即可。 这里面应该有几乎所有的Http头名称，例如：X_FORWARDED_FOR，CONTENT_TYPE，ACCEPT等，用法也没有必要介绍了，直接引用常量就可以了。 4.2 HostAndPort有时候我们需要得到请求的ip，这时候通畅需要自己写方法解析url。而Guava给我们提供的HostAndPort类正是做这种事情的利器，可以从字符串中得到ip和port1HostAndPort.fromString(String hostPortString) 参考资料： Guava API 瓜娃系列 Guava官方文档 Guava教程","tags":[{"name":"Java","slug":"Java","permalink":"http://blog.trang.space/tags/Java/"}]},{"title":"Druid Spring Boot Starter","date":"2017-07-13T07:50:43.154Z","path":"2017/07/13/Druid Spring Boot Starter/","text":"Druid Spring Boot Starter 将帮助你在 Spring Boot 中使用 Druid。 依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.drtrang&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt;&lt;/dependency&gt; 配置简单配置在引入依赖的情况下，只需如下配置即可使用 Druid： 123456spring: datasource: driver-class-name: org.h2.Driver url: jdbc:h2:file:./samples username: root password: 123456 Druid 连接池Druid Spring Boot Starter 会将以 spring.datasource.druid 为前缀的配置注入到 DruidDataSource，且 DruidDataSource 中的所有参数均可自定义。 12345678910111213spring: datasource: druid: initial-size: 1 min-idle: 1 max-active: 10 validation-query: SELECT 1 test-while-idle: true test-on-borrow: false test-on-return: false pool-prepared-statements: true max-open-prepared-statements: 20 use-global-data-source-stat: true Druid 高级特性Druid Spring Boot Starter 添加了 Druid 的大部分特性，如 StatFilter、WallFilter、ConfigFilter、WebStatFilter 等，其中 StatFilter 默认打开，其它特性默认关闭，需要手动开启。 同样，每个特性的参数均可自定义，具体参数可以用 IDE 的自动提示功能或者阅读 Druid 的 Wiki 查看。 123456789101112131415spring: datasource: druid: slf4j: # 开启 Slf4jFilter enabled: true wall: # 开启 WallFilter enabled: true web-stat: # 开启 Web 监控 enabled: true stat-view-servlet: # 开启监控展示 enabled: true 配置示例application.yml 自动提示Druid Spring Boot Starter 基于 spring-boot-configuration-processor 模块，支持 IDE 的自动提示。 该功能会持续优化，致力打造最方便、最友好的 Starter。 自定义参数： 参数说明： 参数枚举值： 演示druid-spring-boot-samples 演示了 Druid Spring Boot Starter 的使用方式，可以作为参考。 更新记录Changelog.md TODO任何意见和建议可以提 Issue，我会酌情加到 Todo List，一般情况一周内迭代完毕。 作者信息QQ：349096849Email：donghao.l@hotmail.com","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.trang.space/tags/SpringBoot/"}]}]